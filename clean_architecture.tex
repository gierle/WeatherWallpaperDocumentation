Softwareprodukte entwickeln sich immer weiter, was heute noch State of the art ist, kann in ein paar Jahren schon wieder durch eine neue Technologie ersetzt worden sein. Deshalb ist es wichtig seine Anwendung so gut wie möglich für Technologie-Änderungen von außen vorzubereiten. Um dies zu ermöglichen, muss in bei den Architekturentscheidung acht gegeben werden. Dabei sollte man sich nicht an äußere Abhängigkeiten binden, sondern diese austauschbar machen. Dabei teilt sich der Quellcode einer Anwendung in mindestens zwei Schichten ein. Der langfristig bestehende Quellcode der Anwendung, sowie der kurzlebige Quellcode der äußeren Abhängigkeiten. Zu diesen äußeren Abhängigkeiten kann beispielsweise eine API gehören. Dieser Schichtenaufbau ist vergleichbar mit einer Matrjoschka oder einer Zwiebel.

Wie bei einer Matrjoschka/Zwiebel auch, muss die Dependency Rule erfüllt sein, damit die Schichten klar aufgeteilt sind und äußere Schichten (relativ) einfach ausgetauscht werden können. Die Dependecy Rule sagt aus, dass Abhängigkeiten immer nur von außen nach innen gehen dürfen. Wenn ein äußerer Zwiebelring ausgetauscht wird, soll dies keine Änderung bzw. Anpassung an einem weiter innen liegenden Zwiebelring bewirken.

Eine Applikation lässt sich in fünf Schichten einteilen, das sind (von innen nach außen):
\begin{itemize}
\item Der Abstraction Code
\begin{itemize}
\item Dieser beinhaltet Code, der sowohl für die eigene Problemdomäne, als auch andere Problemdomänen wichtig sein kann. Hierzu zählen beispielsweise mathematische Grundlagen, wie Vektoren o.Ä.
\end{itemize}
\item Der Domain Code
\begin{itemize}
\item Diese Schicht beinhaltet hauptsächlich Entitäten und sollte sich am wenigsten ändern.
\end{itemize}
\item Der Application Code
\begin{itemize}
\item Im Application Code sind die einzelnen Use Cases wieder zu finden und implementiert damit die Geschäftslogik der Anwendung. Hier werden also die einzelnen Use Cases umgesetzt.
\end{itemize}
\item Die Adapters
\begin{itemize}
\item Diese Schicht handelt, wie der Name schon sagt, als Adapter zwischen den äußeren Plugins und den inneren Schichten. Dabei kann beispielsweise eine Formatkonvertierung stattfinden. Ein Beispiel hierfür wäre eine Web-API, die in der Plugin-Schicht angeordnet ist und ein JSON-String zurückliefert. Der Adapter ist dann für die Konvertierung des JSON-Objekts zu dem Format der Anwendung (z.B. C\#-Objekt) zuständig. Ziel der Adapter ist es, die inneren und äußeren Schichten zu entkoppeln.
\end{itemize}
\item Die Plugins
\begin{itemize}
\item Diese Schicht darf keine Anwendungslogik enthalten, da die Plugins jederzeit änderbar sein müssen. Hier steht quasi nur Pure Fabrication Code. Wird beispielsweise das World-Wide-Web durch eine besondere neue Technologie ersetzt, müssen die Web-APIs ausgetauscht werden. Dies sollte sich nicht auf die anwendungsspezifische Geschäftslogik auswirken.
\end{itemize}
\end{itemize}
Die Applikation wird in einer vier Schichtenarchitektur umgesetzt. Dabei wird auf die erste Schicht, den Abstraction Code, verzichtet.
\subsection{Vorher}
Ein UML-Diagramm mit der Situation vor dem Implementieren der Clean Architecture ist auf unserem Git-Repository \href{https://github.com/Bronzila/WeatherWallpaper/blob/master/CleanArchitecturePics/Architektur_Vorher.jpg}{\color{blue}hier} zu finden. Abhängigkeiten von innen nach außen, die die Dependecy Rule brechen, sind dick und rot hinterlegt. Auf die Abhängigkeitspfeile in die innerste Schicht wurde für die Leserlichkeit verzichtet.
\subsection{Nachher}
Neben der Implementierung der Clean Architecture wurden natürlich auch noch andere Änderungen beispielsweise für die Programming Principles umgesetzt. Daher haben sich manche Klassen aufgeteilt. Das aktuelle Diagramm der Anwendung findet man \href{https://github.com/Bronzila/WeatherWallpaper/blob/master/CleanArchitecturePics/Architektur_Vorher.jpg}{\color{blue}hier}. Hierbei ist erkennbar, dass nun keine Abhängigkeitspfeile von einer inneren zu einer äußeren Schicht gehen und diese mithilfe der Dependency Inversion umgedreht wurden. Damit ist die Depedency Rule erfüllt. Im Folgenden wird nochmals genauer auf die einzelnen Schichten eingegangen.
\subsubsection{Domain Code}
In dieser Schicht reihen sich die Entitäten der Anwendung ein. Dazu gehört die \texttt{Config}, in der das Zeitintervall und der Standort gespeichert ist, sowie die \texttt{Weather}- und \texttt{ImageResponse}, welche die für die Anwendung nötigen Daten der APIs wiedergeben. In der Klasse \texttt{CountryArrays} sind Länder und ihre Abkürzungen hinterlegt. Die \texttt{WeatherInterpretation} wird für die Interpretierung des Wetters verwendet und die \texttt{BadConfigException} ist ein eigener Exception-Typ, der angibt, dass die Konfiguation fehlerhaft ist. Im UML-Diagramm wird erneut auf die Abhängigkeitspfeile in die innerste Schicht verzichtet, damit es lesbarer bleibt.
\subsubsection{Application Code}
Die zentrale Klasse der Anwendung und des Application Codes ist der \texttt{Refresher}. Mithilfe des Refreshers lässt sich, über Delegation an Helferklassen, das Desktophintergrundbild an die aktuelle Wettersituation anpassen. Dafür muss beispielsweise das aktuelle Wetter interpretiert werden, so dass man eine deskriptive Darstellung des Wetters zum Abfragen der Bild-API hat. Dies wird von der \texttt{WeatherInterpreter}-Klasse erledigt. Ein weiterer Use-Case ist die Validierung der vom Nutzer eingegebenen Konfiguration. Darum kümmert sich der \texttt{ConfigValidator}. Dafür arbeitet sie mit den \texttt{IValidationAspects} zusammen. Näheres dazu ist bei dem OCP beschrieben. Die Klassen \texttt{ScreenChangeWorker} und \texttt{UpdateTimer} werden für das aktualisieren mithilfe des Refreshers verwendet. Ersterer wird verwendet, um ein manuelles Aktualisieren in einem neuen Thread zu gewährleisten, damit die GUI nicht blockiert wird. Zweiterer ist für das zyklische Aktualisieren des Hintergrunds zuständig. In dieser Schicht sind ebenfalls die benötigten Interfaces für den Zugriff auf äußere Schichten vorhanden, so dass die Dependency Rule eingehalten wird.
\subsubsection{Adapters}
In der Adapter-Schicht sind sowohl die Adapter für die Wetter- und Bild-API, als auch für die Konfiguration vorhanden. In dem \texttt{Image-} und \texttt{WeatherHandler} werden die JSON-Objekte, die von der API kommen, zu C\#-Objekten gemapt und andersrum mithilfe einer Liste von strings die Routenparameter zusammengebaut und an die API weitergegeben. Der \texttt{ConfigHandler} wandelt die als JSON gespeicherte Konfigurationsdatei in ein C\#-Objekt um, damit diese geladen werden kann. In die andere Richtung wird zum Abspeichern der Konfiguration aus dem C\#-Objekt ein string gemacht. Eine weitere Klasse, die sich in die Adapter-Schicht einordnen lässt, ist der \texttt{MainWindowController}. Hierbei werden die Eingaben der GUI weiter gereicht. Ein Beispiel hierfür ist das manuelle Aktualisieren des Hintergrunds. Dabei gibt die GUI dieses Signal an den \texttt{MainWindowController} weiter, welcher dann mithilfe des \texttt{ScreenChangeWorkers} den Hintergrund aktualisiert.
\subsubsection{Plugins}
In der Plugin-Schicht sind, wie vorher bereits beschrieben unsere \texttt{Image-} und \texttt{WeatherAPICaller} angesiedelt, die falls eine Technologie für die API entwickelt wird bzw. verwendet werden soll nur diese ausgetauscht werden müssen. Dazu gliedert sich auch der \texttt{DownloadHelper} ein, der ein Bild aus dem Internet herunter läd. Der \texttt{ImageWriter} und \texttt{FileAccessor} können einerseits ein Bild auf die Festplatte schreiben, bzw. generell Dateien auf der Festplatte lesen und schreiben. Sollte sich das Dateisystem oder Speichermedium ändern, müsste der Code angepasst werden und ist dementsprechend in der äußersten Schicht. Auch der \texttt{BackgroundChanger} ordnet sich in er Plugin-Schicht ein, da dieser nur für das Windows-Betriebssystem den Hintergrund ändern kann. Möchte man das Betriebssystem ändern, so müsste auch er angepasst werden. Selbes gilt für den \texttt{StartupHelper}, der die Anwendung in den Autostart des Windows-Systems setzt bzw. von dort wieder entfernt. Zu guter Letzt ist die GUI Teil der Plugin-Schicht. Sollte in Zukunft beispielsweise auf eine Web-Oberfläche anstelle einer aktuellen WindowsForms-Oberfläche gewechselt werden, so müsste dieses Plugin angepasst werden.
\begin{itemize}
	\item Schichtarchitektur planen und begründen
	\item $>=$ 2 Schichten umsetzen
\end{itemize}
